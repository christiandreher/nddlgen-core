/**
 * Copyright 2015 Christian Dreher (dreher@charlydelta.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <nddlgen/controllers/NddlGenerationController.h>

nddlgen::controllers::NddlGenerationController::NddlGenerationController()
{

}

nddlgen::controllers::NddlGenerationController::~NddlGenerationController()
{

}

void nddlgen::controllers::NddlGenerationController::writeModelFile(
		nddlgen::models::DomainDescriptionModelPtr domainDescription,
		nddlgen::utilities::WorkflowControllerConfigPtr controllerConfig,
		bool forceOverwrite)
{
	// Assert that the file does not exist yet, unless an overwrite is forced
	if (!forceOverwrite && boost::filesystem::exists(controllerConfig->getOutputModelFile()))
	{
		throw nddlgen::exceptions::FileAlreadyExistsException(controllerConfig->getOutputModelFile());
	}

	// Open output file stream
	std::ofstream ofStream(controllerConfig->getOutputModelFile());

	// Initialize needed variables (short-hands)
	std::string nddlgenVersion = nddlgen::utilities::Meta::NDDLGEN_VERSION;
	std::string nddlgenProjectHomepage = nddlgen::utilities::Meta::NDDLGEN_PROJECT_HOMEPAGE;
	std::string nddlgenSupportEmail = nddlgen::utilities::Meta::NDDLGEN_SUPPORT_EMAIL;
	std::string authorChrDreherEmail = nddlgen::utilities::Meta::AUTHOR_CHR_DREHER_EMAIL;
	std::string adapter = controllerConfig->getAdapter();
	std::string outputFile = controllerConfig->getOutputModelFileName();
	std::string sdfInputFile = controllerConfig->getSdfInputFileName();
	std::string sdfInputFilePath = controllerConfig->getSdfInputFilePath();
	std::string now = NddlGenerationController::getPrettifiedDate();

	// Disclaimer / Meta
	wrln(0, "// Generated by nddlgen <" + nddlgenProjectHomepage + ">", 1);
	wrln(0, "// Author: Christian Dreher <" + authorChrDreherEmail + ">", 1);
	wrln(0, "// Support: <" + nddlgenSupportEmail + ">", 2);

	wrln(0, "// This NDDL model file (" + outputFile + ") was generated from ", 1);
	wrln(0, "// \"" + sdfInputFile + "\" originally located in \"" + sdfInputFilePath + "\" by", 1);
	wrln(0, "// nddlgen-core v" + nddlgenVersion + " using " + adapter + "", 1);
	wrln(0, "// Creation date: " + now, 2);

	// Call generateModel() of sub-objects
	domainDescription->getArm()->generateModel(ofStream);

	// Model file generated, close stream
	ofStream.close();
}

void nddlgen::controllers::NddlGenerationController::writeInitialStateFile(
		nddlgen::models::DomainDescriptionModelPtr domainDescription,
		nddlgen::utilities::WorkflowControllerConfigPtr controllerConfig,
		bool forceOverwrite)
{
	// Assert that the file does not exist yet, unless an overwrite is forced
	if (!forceOverwrite && boost::filesystem::exists(controllerConfig->getOutputInitialStateFile()))
	{
		throw nddlgen::exceptions::FileAlreadyExistsException(controllerConfig->getOutputInitialStateFile());
	}

	// Open output file stream
	std::ofstream ofStream(controllerConfig->getOutputInitialStateFile());

	// Initialize needed variables (short-hands)
	std::string nddlgenVersion = nddlgen::utilities::Meta::NDDLGEN_VERSION;
	std::string nddlgenProjectHomepage = nddlgen::utilities::Meta::NDDLGEN_PROJECT_HOMEPAGE;
	std::string nddlgenSupportEmail = nddlgen::utilities::Meta::NDDLGEN_SUPPORT_EMAIL;
	std::string authorChrDreherEmail = nddlgen::utilities::Meta::AUTHOR_CHR_DREHER_EMAIL;
	std::string adapter = controllerConfig->getAdapter();
	std::string outputFile = controllerConfig->getOutputInitialStateFileName();
	std::string sdfInputFile = controllerConfig->getSdfInputFileName();
	std::string isdInputFile = controllerConfig->getIsdInputFileName();
	std::string sdfInputFilePath = controllerConfig->getSdfInputFilePath();
	std::string isdInputFilePath = controllerConfig->getIsdInputFilePath();
	std::string now = NddlGenerationController::getPrettifiedDate();

	// Disclaimer / Meta
	wrln(0, "// Generated by nddlgen <" + nddlgenProjectHomepage + ">", 1);
	wrln(0, "// Author: Christian Dreher <" + authorChrDreherEmail + ">", 1);
	wrln(0, "// Support: <" + nddlgenSupportEmail + ">", 2);

	wrln(0, "// This NDDL initial state file (" + outputFile + ") was generated from ", 1);
	wrln(0, "// \"" + sdfInputFile + "\" originally located in \"" + sdfInputFilePath + "\" and", 1);
	wrln(0, "// \"" + isdInputFile + "\" originally located in \"" + isdInputFilePath + "\" by", 1);
	wrln(0, "// nddlgen-core v" + nddlgenVersion + " using " + adapter + "", 1);
	wrln(0, "// Creation date: " + now, 2);

	// Inlcude NDDL model file
	wrln(0, "#include \"" + controllerConfig->getOutputModelFileName() + "\"", 2);

	// Instantiate models on workspace
	nddlgen::types::NddlGeneratableList models = domainDescription->getArm()->getWorkspace()->getModels();

	foreach (nddlgen::models::NddlGeneratablePtr generatableModel, models)
	{
		std::string className = generatableModel->getClassName();
		std::string instanceName = generatableModel->getName();

		wrln(0, className + " " + instanceName + " = new " + className + "();", 1);
	}

	wrel(1);

	// Instantiate Workspace
	std::string workspaceClassName = domainDescription->getArm()->getWorkspace()->getClassName();
	std::string workspaceInstanceName = domainDescription->getArm()->getWorkspace()->getName();
	std::string workspaceConstructorParameters = "";

	foreach (nddlgen::models::NddlGeneratablePtr generatableModel, models)
	{
		workspaceConstructorParameters += generatableModel->getName() + ", ";
	}

	workspaceConstructorParameters = workspaceConstructorParameters.substr(0, workspaceConstructorParameters.size() - 2);

	wrln(0, workspaceClassName + " " + workspaceInstanceName + " = new " + workspaceClassName + "(" + workspaceConstructorParameters + ");", 2);

	// Instantiate Arm
	std::string armClassName = domainDescription->getArm()->getClassName();
	std::string armInstanceName = domainDescription->getArm()->getName();

	wrln(0, armClassName + " " + armInstanceName + " = new " + armClassName + "(" + workspaceInstanceName + ");", 2);

	// Close model instantiation (NDDL procedure call)
	wrln(0, "close();", 2);

	// Print facts
	nddlgen::types::FactList facts = domainDescription->getInitialState()->getFacts();

	foreach (nddlgen::utilities::InitialStateFactPtr fact, facts)
	{
		std::list<std::string> factLines = fact->getFact();

		foreach (std::string factLine, factLines)
		{
			wrln(0, factLine, 1);
		}

		wrel(1);
	}

	// Print goals
	nddlgen::types::GoalList goals = domainDescription->getInitialState()->getGoals();

	foreach (nddlgen::utilities::InitialStateGoalPtr goal, goals)
	{
		std::list<std::string> goalLines = goal->getGoal();

		foreach (std::string goalLine, goalLines)
		{
			wrln(0, goalLine, 1);
		}

		wrel(1);
	}

	// Close stream
	ofStream.close();
}

std::string nddlgen::controllers::NddlGenerationController::getPrettifiedDate()
{
	// Get POSIX time
	std::string date = boost::posix_time::to_iso_extended_string(boost::posix_time::second_clock::local_time());

	// Replace T with space: "yyyymmddThh:MM:ss" => "yyyymmdd hh:MM:ss"
	boost::replace_all(date, "T", " ");

	// Return prettified date
	return date;
}
